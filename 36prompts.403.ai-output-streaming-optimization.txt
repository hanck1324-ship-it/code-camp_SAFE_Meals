ì•„ë˜ì˜ ì¡°ê±´ì„ ëª¨ë‘ ì ìš©í•˜ì—¬, ì•„ë˜ì˜ ìš”êµ¬ì‚¬í•­ì„ ëª¨ë‘ êµ¬í˜„í•  ê²ƒ.
êµ¬í˜„ ê²°ê³¼ë¥¼ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•  ê²ƒ.

==============================================


ì¡°ê±´-íŒŒì¼ê²½ë¡œ) ìˆ˜ì •ë  API íŒŒì¼ê²½ë¡œ: apps/web/src/app/api/scan/analyze/route.ts
ì¡°ê±´-íŒŒì¼ê²½ë¡œ) êµ¬í˜„ë  í”„ë¡¬í”„íŠ¸ íŒŒì¼ê²½ë¡œ: apps/web/src/lib/prompts/allergy-classifier.prompt.ts
ì¡°ê±´-íŒŒì¼ê²½ë¡œ) êµ¬í˜„ë  í›… íŒŒì¼ê²½ë¡œ: apps/web/src/features/scan/components/menu-scan/hooks/useStreamingResult.hook.ts
ì¡°ê±´-íŒŒì¼ê²½ë¡œ) êµ¬í˜„ë  í…ŒìŠ¤íŠ¸ íŒŒì¼ê²½ë¡œ: apps/web/tests/streaming-result.spec.ts

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­) AI ì¶œë ¥ì„ ìµœì†Œí™”í•˜ê³  ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ì²« í† í° UXë¥¼ ìµœì í™”í•  ê²ƒ.

ëª©í‘œ:
- "ì™„ë£Œ ì†ë„"ê°€ ì•„ë‹ˆë¼ "ì²« íŒë‹¨ ì‹œê°„" ë‹¨ì¶•
- UX ì²´ê° ì†ë„ì— ì§ì ‘ ì˜í–¥
- ìŠ¤íŠ¸ë¦¬ë° UXì™€ ë°˜ë“œì‹œ ë³‘í–‰ ì ìš©

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­-1) "ì‚¬ê³  ê¸ˆì§€ íŒë³„ê¸°" í”„ë¡¬í”„íŠ¸ ì„¤ê³„

1) í”„ë¡¬í”„íŠ¸ ì›ì¹™
   - LLMì—ê²Œ "ìƒê°í•˜ì§€ ë§ê³  ë¶„ë¥˜ë§Œ í•˜ê²Œ" ê°•ì œ
   - ì„¤ëª…/ë¶„ì„/ì¶”ë¡  ê¸ˆì§€
   - **ë‹¨ì¼ ë¬¸ì(S/C/D) ì¶œë ¥ìœ¼ë¡œ í† í° 1ê°œ ë³´ì¥**

2) í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ (allergy-classifier.prompt.ts)

   ```typescript
   export const ALLERGY_CLASSIFIER_PROMPT = `
   You are an allergy classifier.
   
   DECISION RULES (strictly follow):
   - D: ì‚¬ìš©ì ì•Œë ˆë¥´ê¸°ì™€ ì§ì ‘ ë§¤ì¹­ í† í°ì´ 1ê°œë¼ë„ ìˆìœ¼ë©´
   - S: ì§ì ‘ ë§¤ì¹­ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´
   
   **ì£¼ì˜**: 1ì°¨ íŒì •ì€ 2ë¶„ë¥˜(S/D)ë§Œ ì‚¬ìš©.
   CAUTION(C)ì€ 2ì°¨ ìƒì„¸ ë¶„ì„ì—ì„œë§Œ ì‚¬ìš© (êµì°¨ì˜¤ì—¼/may_contain ì •ë³´ í•„ìš”)
   
   OUTPUT RULES:
   - Output ONLY one character: S or D
   - S = SAFE, D = DANGER
   - NO explanation, NO reasoning, NO additional text
   
   User allergies: {user_allergies}
   Menu ingredients: {menu_tokens}
   
   Classification:`;
   ```

   **í´ë¼ì´ì–¸íŠ¸ ë§¤í•‘**:
   ```typescript
   const STATUS_MAP: Record<string, 'SAFE' | 'DANGER'> = {
     'S': 'SAFE',
     'D': 'DANGER',
   };
   ```

3) âŒ ê¸ˆì§€ íŒ¨í„´ (ëŠë¦¼)
   - "ë¶„ì„í•´ì„œ ì„¤ëª…í•´ì¤˜"
   - "ì™œ ìœ„í—˜í•œì§€ ì•Œë ¤ì¤˜"
   - "ê° ì¬ë£Œë³„ë¡œ í‰ê°€í•´ì¤˜"
   - "SAFE/CAUTION/DANGER ë‹¨ì–´ë¡œ ì¶œë ¥" (í† í¬ë‚˜ì´ì €ê°€ ì—¬ëŸ¬ í† í°ìœ¼ë¡œ ë¶„í•  ê°€ëŠ¥)

4) âœ… ê¶Œì¥ íŒ¨í„´ (ë¹ ë¦„)
   - "S/D ì¤‘ í•˜ë‚˜ë§Œ ì¶œë ¥" (enum ê°•ì œë¡œ í™•ì •ì  ì¶œë ¥)
   - "ì„¤ëª… ê¸ˆì§€"
   - **ê²°ì • ê·œì¹™ì„ ëª…ì‹œ** (ì¼ê´€ì„± í™•ë³´)
   
   **ì£¼ì˜**: "ë‹¨ì¼ ë¬¸ì = ë‹¨ì¼ í† í°"ì€ í† í¬ë‚˜ì´ì €ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ.
   í•˜ì§€ë§Œ text/x.enum + responseSchemaë¡œ enum ê°•ì œí•˜ë©´ UX ëª©ì  ë‹¬ì„±.

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­-2) ëª¨ë¸ íŒŒë¼ë¯¸í„° ìµœì í™”

**ì¤‘ìš”**: Gemini APIì—ì„œ logit_biasëŠ” ê³µì‹ ë¯¸ì§€ì›. text/x.enum + responseSchemaë¡œ ëŒ€ì²´.

1) í•„ìˆ˜ ì„¤ì •
   ```typescript
   const generationConfig = {
     maxOutputTokens: 3,        // S/D + ì—¬ìœ  (1ê°œëŠ” ì˜ë¦¼ ìœ„í—˜)
     temperature: 0,            // ê²°ì •ë¡ ì  ì¶œë ¥ (ì¼ê´€ì„±)
     topP: 1,                   // nucleus sampling ë¹„í™œì„±í™”
     topK: 1,                   // greedy decoding
     stopSequences: ["\n"],     // ì¤„ë°”ê¿ˆì—ì„œë§Œ ì¤‘ë‹¨ (ê³µë°± ì œì™¸ - ë¹ˆ ì‘ë‹µ ìœ„í—˜)
   };
   ```

2) ì‘ë‹µ í˜•ì‹ ê°•ì œ (**text/x.enum ì‚¬ìš© - ê°€ì¥ ì•ˆì •ì **)
   ```typescript
   const generationConfig = {
     responseMimeType: "text/x.enum",  // enum ì¶œë ¥ ì „ìš© MIME íƒ€ì…
     responseSchema: {
       type: "string",
       enum: ["S", "D"]  // 2ë¶„ë¥˜ë¡œ ë‹¨ìˆœí™”
     },
     stopSequences: ["\n"],  // ê³µë°± ì œì™¸ (ë¹ˆ ì‘ë‹µ ìœ„í—˜)
   };
   ```
   
   **ì£¼ì˜**: 
   - âŒ responseMimeType: "text/plain" + responseSchema ì¡°í•©ì€ ë¶ˆì•ˆì •
   - âœ… responseMimeType: "text/x.enum" + responseSchema.enum ì¡°í•©ì´ ê°€ì¥ ê°•ë ¥

3) thinkingConfig (Gemini 2.0+ ì§€ì› ì‹œ)
   ```typescript
   // "ìƒê°" ê¸°ëŠ¥ì´ ìˆëŠ” ëª¨ë¸ì—ì„œ thinking budget ìµœì†Œí™”
   const generationConfig = {
     thinkingConfig: {
       thinkingBudget: 0,  // ë¶„ë¥˜ íƒœìŠ¤í¬ì—ëŠ” thinking ë¶ˆí•„ìš”
     },
     // ... ê¸°íƒ€ ì„¤ì •
   };
   ```

4) âŒ ì‚¬ìš© ê¸ˆì§€ (Gemini ë¯¸ì§€ì› ë˜ëŠ” ë¶ˆì•ˆì •)
   - logit_bias: Gemini API ê³µì‹ ë¯¸ì§€ì›
   - maxOutputTokens: 1 (í† í° ì˜ë¦¼ ìœ„í—˜)

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­-3) ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ êµ¬í˜„

**í”„ë¡œí† ì½œ ì„ íƒ**: fetch streaming + NDJSON (SSE ì•„ë‹˜)
- SSE(EventSource)ëŠ” GET ê¸°ë°˜ì´ë¼ POST body ì „ì†¡ ë¶ˆê°€
- fetch streaming + NDJSONì´ ë” ë‹¨ìˆœí•˜ê³  ì•ˆì •ì 

1) API ë¼ìš°íŠ¸ ìŠ¤íŠ¸ë¦¬ë° ì„¤ì • (/api/scan/analyze)
   **ì£¼ì˜**: ê¸°ì¡´ route.tsë¥¼ ìˆ˜ì •. ë³„ë„ ì—”ë“œí¬ì¸íŠ¸ ìƒì„± ì•„ë‹˜.
   
   **í˜¸í™˜ì„± ìœ ì§€ (Content Negotiation)**:
   - `Accept: application/x-ndjson` â†’ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
   - ê·¸ ì™¸ â†’ ê¸°ì¡´ JSON ì‘ë‹µ (í˜¸í™˜ì„± ìœ ì§€)
   
   ```typescript
   // apps/web/src/app/api/scan/analyze/route.ts
   export async function POST(req: NextRequest) {
     const startTime = Date.now();
     const acceptHeader = req.headers.get('Accept') || '';
     const wantsStream = acceptHeader.includes('application/x-ndjson');
     
     // ... í† í° ìµœì í™” í›„
     
     // ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­ì´ ì•„ë‹ˆë©´ ê¸°ì¡´ JSON ì‘ë‹µ
     if (!wantsStream) {
       const result = await model.generateContent([prompt, imagePart]);
       const text = result.response.text().trim();
       const status = parseStatus(text);
       return NextResponse.json({ status, ttft: Date.now() - startTime });
     }
     
     // ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
     const result = await model.generateContentStream([prompt, imagePart]);
     
     // NDJSON ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ìƒì„±
     const encoder = new TextEncoder();
     const stream = new ReadableStream({
       async start(controller) {
         let firstChunkSent = false;
         let accumulated = '';
         let ttftMs: number | null = null;  // TTFTëŠ” ì²« ì²­í¬ì—ì„œ ì¸¡ì •
         
         for await (const chunk of result.stream) {
           const text = chunk.text();
           accumulated += text;
           
           if (!firstChunkSent) {
             // TTFT(Time To First Token) ì¸¡ì • - ì²« ì²­í¬ ì‹œì 
             ttftMs = Date.now() - startTime;
             console.log(`âš¡ TTFT: ${ttftMs}ms`);
             firstChunkSent = true;
           }
           
           // NDJSON í˜•ì‹ (í”„ë¡œë•ì…˜ì—ì„œëŠ” accumulated ì œì™¸)
           const payload = process.env.NODE_ENV === 'development'
             ? { text, accumulated }  // ë””ë²„ê·¸ìš©
             : { text };              // í”„ë¡œë•ì…˜ìš© (í˜ì´ë¡œë“œ ìµœì†Œí™”)
           controller.enqueue(
             encoder.encode(JSON.stringify(payload) + '\n')
           );
         }
         
         // ìµœì¢… ê²°ê³¼ ì „ì†¡ (ttftëŠ” ì²« ì²­í¬ ì‹œì  ê°’)
         const finalStatus = parseStatus(accumulated.trim());
         controller.enqueue(
           encoder.encode(JSON.stringify({ 
             done: true, 
             status: finalStatus,
             ttft: ttftMs  // TTFT (ì´ ì†Œìš” ì‹œê°„ ì•„ë‹˜!)
           }) + '\n')
         );
         controller.close();
       }
     });
     
     return new Response(stream, {
       headers: {
         'Content-Type': 'application/x-ndjson',
         'Cache-Control': 'no-cache, no-store, must-revalidate',
         'X-Accel-Buffering': 'no',  // Nginx ë²„í¼ë§ ë¹„í™œì„±í™”
         'Transfer-Encoding': 'chunked',
       }
     });
   }
   
   // S/D â†’ SAFE/DANGER ë§¤í•‘ (2ë¶„ë¥˜)
   // **ì¹˜ëª…ì  ì•ˆì „ ê·œì¹™**: fallbackì€ ë°˜ë“œì‹œ DANGER
   // ì•Œë ˆë¥´ê¸° ë„ë©”ì¸ì—ì„œ "false SAFE"ëŠ” ì‚¬ê³ ë¡œ ì´ì–´ì§
   function parseStatus(raw: string): 'SAFE' | 'DANGER' {
     const match = raw.toUpperCase().match(/[SD]/);
     if (!match) return 'DANGER';  // âš ï¸ ë³´ìˆ˜ì  ì•ˆì „: íŒì • ì‹¤íŒ¨ ì‹œ DANGER
     return match[0] === 'S' ? 'SAFE' : 'DANGER';
   }
   ```
   
   **âŒ ê¸ˆì§€ íŒ¨í„´ (fallback: SAFE)**:
   ```typescript
   // ìœ„í—˜! ë¹ˆ ë¬¸ìì—´/ì˜ˆì™¸ ì¶œë ¥ ì‹œ "ì•ˆì „"ìœ¼ë¡œ íŒì •
   return char.toUpperCase() === 'D' ? 'DANGER' : 'SAFE';  // âŒ ì ˆëŒ€ ê¸ˆì§€
   ```

2) ì‘ë‹µ êµ¬ì¡° (NDJSON - ì¤„ ë‹¨ìœ„ JSON)
   ```
   {"text":"D"}
   {"done":true,"status":"DANGER","ttft":723}
   ```
   
   **í”„ë¡œë•ì…˜ vs ê°œë°œ**:
   - ê°œë°œ: `{"text":"D","accumulated":"D"}` (ë””ë²„ê¹…ìš©)
   - í”„ë¡œë•ì…˜: `{"text":"D"}` (í˜ì´ë¡œë“œ ìµœì†Œí™”)
   
   **SSE í˜•ì‹ ì‚¬ìš© ì•ˆ í•¨**:
   - âŒ `data: {"text": "D"}\n\n` (SSE)
   - âœ… `{"text":"D"}\n` (NDJSON)

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­-4) í´ë¼ì´ì–¸íŠ¸ ìŠ¤íŠ¸ë¦¬ë° í›… êµ¬í˜„

**í•µì‹¬**: ì²­í¬ ê²½ê³„ ë¬¸ì œ í•´ê²° + useRefë¡œ ë ˆì´ìŠ¤ ì¡°ê±´ ë°©ì§€ + AbortControllerë¡œ ì—°ì† ìš”ì²­ ê´€ë¦¬

**ì¤‘ìš”**: 
- useRefëŠ” í›… ìµœìƒìœ„ì—ì„œ ì„ ì–¸! (startStreaming ë‚´ë¶€ âŒ)
- startStreamingì€ payloadë¥¼ ì¸ìë¡œ ë°›ìŒ (stale closure ë°©ì§€)

1) í›… ì‹œê·¸ë‹ˆì²˜
   ```typescript
   // (CR-2 í•´ê²°) startStreamingì´ ëª¨ë“  í•„ìš” ë°ì´í„°ë¥¼ ì¸ìë¡œ ë°›ìŒ
   interface StreamingPayload {
     image: string;
     userAllergies: string[];
     menuTokens: string[];
   }
   
   interface UseStreamingResultReturn {
     status: 'SAFE' | 'DANGER' | null;  // 2ë¶„ë¥˜
     isStreaming: boolean;
     firstTokenTime: number | null;  // ms (TTFT)
     error: string | null;
     startStreaming: (payload: StreamingPayload) => Promise<void>;
     abort: () => void;  // (H-1) ìˆ˜ë™ ì·¨ì†Œ ì§€ì›
   }
   
   function useStreamingResult(): UseStreamingResultReturn
   ```

2) ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬ ë¡œì§ (ëª¨ë“  ë ˆì´ìŠ¤ ì¡°ê±´ í•´ê²°)
   
   **âŒ ì˜ëª»ëœ ì˜ˆ (stale closure + Hooks ê·œì¹™ ìœ„ë°˜)**:
   ```typescript
   const startStreaming = useCallback(async (image: string) => {
     // âŒ user_allergies, menu_tokensê°€ ì–´ë””ì„œ ì˜¤ëŠ”ì§€ ë¶ˆëª…í™•
     // âŒ depsê°€ []ì´ë¯€ë¡œ ìµœì‹  ê°’ ë°˜ì˜ ì•ˆ ë¨
     body: JSON.stringify({ image, user_allergies, menu_tokens }),
   }, []);  // âŒ ë¹ˆ deps
   ```
   
   **âœ… ì˜¬ë°”ë¥¸ ì˜ˆ (payload ì¸ì + AbortController)**:
   ```typescript
   function useStreamingResult(): UseStreamingResultReturn {
     const [status, setStatus] = useState<'SAFE' | 'DANGER' | null>(null);
     const [isStreaming, setIsStreaming] = useState(false);
     const [firstTokenTime, setFirstTokenTime] = useState<number | null>(null);
     const [error, setError] = useState<string | null>(null);
     
     // âœ… í›… ìµœìƒìœ„ì—ì„œ ì„ ì–¸
     const firstTokenCapturedRef = useRef(false);
     const abortControllerRef = useRef<AbortController | null>(null);
     const requestIdRef = useRef(0);  // (H-1) ì—°ì† ìš”ì²­ ë ˆì´ìŠ¤ ë°©ì§€
     
     // (H-1) ì´ì „ ìš”ì²­ ì·¨ì†Œ
     const abort = useCallback(() => {
       abortControllerRef.current?.abort();
     }, []);
     
     const startStreaming = useCallback(async (payload: StreamingPayload) => {
       const { image, userAllergies, menuTokens } = payload;
       
       // (H-1) ì´ì „ ìš”ì²­ ì·¨ì†Œ + ìƒˆ requestId
       abort();
       const currentRequestId = ++requestIdRef.current;
       abortControllerRef.current = new AbortController();
       
       setIsStreaming(true);
       setError(null);
       setStatus(null);
       firstTokenCapturedRef.current = false;
       
       const startTime = Date.now();
       let localFirstTokenTime: number | null = null;
       let buffer = '';
       
       try {
         const response = await fetch('/api/scan/analyze', {
           method: 'POST',
           headers: { 
             'Content-Type': 'application/json',
             'Accept': 'application/x-ndjson',  // (H-2) ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­ ëª…ì‹œ
           },
           body: JSON.stringify({ 
             image, 
             user_allergies: userAllergies, 
             menu_tokens: menuTokens 
           }),
           signal: abortControllerRef.current.signal,  // (H-1) ì·¨ì†Œ ì§€ì›
         });
         
         if (!response.ok) throw new Error('Stream failed');
         
         const reader = response.body?.getReader();
         const decoder = new TextDecoder();
         
         while (true) {
           const { done, value } = await reader!.read();
           if (done) break;
           
           // (H-1) ì´ë¯¸ ì·¨ì†Œëœ ìš”ì²­ì´ë©´ ë¬´ì‹œ
           if (currentRequestId !== requestIdRef.current) return;
           
           buffer += decoder.decode(value, { stream: true });
           
           const lines = buffer.split('\n');
           buffer = lines.pop() || '';
           
           for (const line of lines) {
             if (!line.trim()) continue;
             
             try {
               const data = JSON.parse(line);
               
               if (!firstTokenCapturedRef.current && data.text) {
                 localFirstTokenTime = Date.now() - startTime;
                 firstTokenCapturedRef.current = true;
               }
               
               if (data.done && data.status) {
                 // (H-1) ìµœì‹  ìš”ì²­ë§Œ ìƒíƒœ ì—…ë°ì´íŠ¸
                 if (currentRequestId === requestIdRef.current) {
                   setStatus(data.status);
                 }
               }
               }
             } catch (e) {
               // JSON íŒŒì‹± ì‹¤íŒ¨ - ë¬´ì‹œ
             }
           }
         }
         
         // (H-1) ìµœì‹  ìš”ì²­ë§Œ ìƒíƒœ ì—…ë°ì´íŠ¸
         if (currentRequestId === requestIdRef.current) {
           setFirstTokenTime(localFirstTokenTime);
         }
         
       } catch (err) {
         // AbortErrorëŠ” ì •ìƒ ì·¨ì†Œì´ë¯€ë¡œ ì—ëŸ¬ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
         if (err instanceof Error && err.name === 'AbortError') {
           return;
         }
         if (currentRequestId === requestIdRef.current) {
           setError(err instanceof Error ? err.message : 'Unknown error');
         }
       } finally {
         if (currentRequestId === requestIdRef.current) {
           setIsStreaming(false);
         }
       }
     }, [abort]);  // abortë§Œ depsì— í¬í•¨ (payloadëŠ” ì¸ìë¡œ ë°›ìŒ)
     
     return { status, isStreaming, firstTokenTime, error, startStreaming, abort };
   }
   ```

3) í•µì‹¬ í•´ê²° í¬ì¸íŠ¸
   
   **â‘  ì²­í¬ ê²½ê³„ ë¬¸ì œ í•´ê²°**:
   - buffer ëˆ„ì  â†’ `\n` ë‹¨ìœ„ í”„ë ˆì„ ë¶„ë¦¬
   - ë¶ˆì™„ì „ ë¼ì¸ì€ bufferì— ìœ ì§€í•˜ê³  ë‹¤ìŒ ì²­í¬ì™€ í•©ì¹¨
   
   **â‘¡ ë ˆì´ìŠ¤ ì¡°ê±´ ë°©ì§€ (firstTokenTime)**:
   - `firstTokenTime === null` state ë¹„êµ âŒ
   - `useRef` + ë¡œì»¬ ë³€ìˆ˜ë¡œ ë¨¼ì € ìº¡ì²˜ âœ…
   - ë£¨í”„ ì¢…ë£Œ í›„ í•œ ë²ˆë§Œ state ë°˜ì˜
   
   **â‘¢ ì—°ì† ìš”ì²­ ë ˆì´ìŠ¤ ë°©ì§€ (H-1)**:
   - `AbortController`ë¡œ ì´ì „ ìš”ì²­ ì·¨ì†Œ
   - `requestIdRef`ë¡œ ìµœì‹  ìš”ì²­ë§Œ ìƒíƒœ ì—…ë°ì´íŠ¸
   - ì·¨ì†Œëœ ìš”ì²­ì˜ ì‘ë‹µì€ ë¬´ì‹œ
   
   **â‘£ stale closure ë°©ì§€ (CR-2)**:
   - `startStreaming(payload)`ê°€ ëª¨ë“  ë°ì´í„°ë¥¼ ì¸ìë¡œ ë°›ìŒ
   - `useCallback` depsê°€ `[]`ì´ì–´ë„ ì•ˆì „
   - ì»´í¬ë„ŒíŠ¸ì—ì„œ: `startStreaming({ image, userAllergies, menuTokens })`

4) ì»´í¬ë„ŒíŠ¸ ì‚¬ìš© ì˜ˆì‹œ
   ```typescript
   const { status, firstTokenTime, isStreaming, startStreaming, abort } = useStreamingResult();
   
   const handleScan = async () => {
     // (CR-2) payloadë¡œ ëª¨ë“  ë°ì´í„° ì „ë‹¬
     await startStreaming({ 
       image: imageData, 
       userAllergies: ['shellfish', 'eggs'], 
       menuTokens: ['shrimp', 'pasta'] 
     });
   };
   
   // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ìš”ì²­ ì·¨ì†Œ
   useEffect(() => {
     return () => abort();
   }, [abort]);
   
   useEffect(() => {
     if (status === 'DANGER') {
       showWarningBanner();
     }
   }, [status]);
   ```

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­-5) 2ë‹¨ê³„ ìŠ¤íŠ¸ë¦¬ë° ì „ëµ (ì„ íƒì  í™•ì¥)

1) 1ë‹¨ê³„: ë¹ ë¥¸ íŒì • (0.5~1ì´ˆ)
   - ì¶œë ¥: S ë˜ëŠ” D (2ë¶„ë¥˜)
   - í”„ë¡¬í”„íŠ¸: ì‚¬ê³  ê¸ˆì§€ íŒë³„ê¸°
   - ì¦‰ì‹œ UI ë°˜ì˜

2) 2ë‹¨ê³„: ìƒì„¸ ë¶„ì„ (ë°±ê·¸ë¼ìš´ë“œ, 2~5ì´ˆ)
   - ì¶œë ¥: ìœ„í—˜ ì¬ë£Œ, ì´ìœ , ëŒ€ì•ˆ, CAUTION íŒì • ë“±
   - ê¸°ì¡´ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
   - í´ë§ ë˜ëŠ” ë³‘ë ¬ ìŠ¤íŠ¸ë¦¬ë°

3) íƒ€ì„ë¼ì¸ ì˜ˆì‹œ
   ```
   0.0ì´ˆ  ìš”ì²­ ì „ì†¡
   0.7ì´ˆ  âš ï¸ "ìœ„í—˜" ë°°ë„ˆ í‘œì‹œ (1ë‹¨ê³„ ì™„ë£Œ)
   1.5ì´ˆ  "ìš°ìœ  ì„±ë¶„ í¬í•¨" ìƒì„¸ ì •ë³´ (2ë‹¨ê³„ ì§„í–‰ ì¤‘)
   3.0ì´ˆ  ì „ì²´ ë¶„ì„ ì™„ë£Œ (2ë‹¨ê³„ ì™„ë£Œ)
   ```

==============================================

í•µì‹¬ìš”êµ¬ì‚¬í•­-6) í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

**ì¤‘ìš” (H-3)**: ì‹œê°„ ê¸°ë°˜ í…ŒìŠ¤íŠ¸("<1ì´ˆ")ëŠ” CIì—ì„œ í”Œë˜í‚¤í•¨.
- ë„¤íŠ¸ì›Œí¬/ëŸ°íƒ€ì„/ë¶€í•˜ì— ë”°ë¼ ì‹œê°„ì´ í”ë“¤ë¦¼
- **ê°€ì§œ ReadableStream + vitest fake timersë¡œ ë…¼ë¦¬ë§Œ ê²€ì¦**

1) ì²« í† í° ë¡œì§ í…ŒìŠ¤íŠ¸ (ì‹œê°„ ì•„ë‹Œ ë¡œì§ ê²€ì¦)
   - ì¡°ê±´: ê°€ì§œ ReadableStreamìœ¼ë¡œ ì²­í¬ ì „ì†¡
   - ê¸°ëŒ€: ì²« ì²­í¬ ë„ì°© ì‹œ firstTokenCapturedRef.current = true
   - ê²€ì¦: **ì‹œê°„ì´ ì•„ë‹Œ ë¡œì§** ë™ì‘ í™•ì¸
   
   ```typescript
   // Mock ReadableStream ì˜ˆì‹œ
   const mockStream = new ReadableStream({
     start(controller) {
       controller.enqueue(new TextEncoder().encode('{"text":"D"}\n'));
       controller.close();
     }
   });
   ```

2) ì¶œë ¥ í˜•ì‹ í…ŒìŠ¤íŠ¸
   - ì¡°ê±´: ë‹¤ì–‘í•œ ì…ë ¥ ì¡°í•©
   - ê¸°ëŒ€: S ë˜ëŠ” Dë§Œ ì¶œë ¥ (2ë¶„ë¥˜)
   - ê²€ì¦: text/x.enum + responseSchemaë¡œ ê°•ì œ, ì¶”ê°€ í…ìŠ¤íŠ¸ ì—†ìŒ

3) ìŠ¤íŠ¸ë¦¬ë° ì—°ê²° í…ŒìŠ¤íŠ¸
   - ì¡°ê±´: fetch streaming + NDJSON
   - ê¸°ëŒ€: ì¤„ ë‹¨ìœ„ JSON ìˆ˜ì‹ 
   - ê²€ì¦: buffer ëˆ„ì  â†’ `\n` ë¶„ë¦¬ â†’ JSON.parse ì„±ê³µ

4) ì²­í¬ ê²½ê³„ í…ŒìŠ¤íŠ¸
   - ì¡°ê±´: ì¸ìœ„ì ìœ¼ë¡œ ì²­í¬ë¥¼ ë¶„í• í•˜ì—¬ ì „ì†¡
   - ê¸°ëŒ€: `{"tex` + `t":"D"}` ë¶„ë¦¬ë˜ì–´ë„ íŒŒì‹± ì„±ê³µ
   - ê²€ì¦: buffer ëˆ„ì  ë¡œì§ ì •ìƒ ë™ì‘

5) ì¼ê´€ì„± í…ŒìŠ¤íŠ¸
   - ì¡°ê±´: ë™ì¼ ì…ë ¥ 10íšŒ ë°˜ë³µ
   - ê¸°ëŒ€: ë™ì¼ ì¶œë ¥ (temperature=0)
   - ê²€ì¦: ê²°ê³¼ ì¼ì¹˜ìœ¨ 100%

6) ì—°ì† ìš”ì²­ ë ˆì´ìŠ¤ í…ŒìŠ¤íŠ¸ (H-1)
   - ì¡°ê±´: ìš”ì²­ A ì‹œì‘ â†’ ìš”ì²­ B ì‹œì‘ â†’ A ì‘ë‹µ ë„ì°©
   - ê¸°ëŒ€: A ì‘ë‹µ ë¬´ì‹œ, B ì‘ë‹µë§Œ ìƒíƒœì— ë°˜ì˜
   - ê²€ì¦: requestIdRef ë¡œì§ + AbortController ë™ì‘

7) parseStatus fallback í…ŒìŠ¤íŠ¸ (CR-1)
   - ì¡°ê±´: ë¹ˆ ë¬¸ìì—´, "X", "123", undefined ì…ë ¥
   - ê¸°ëŒ€: ëª¨ë‘ DANGER ë°˜í™˜
   - ê²€ì¦: **fallbackì´ SAFEê°€ ì•„ë‹˜** í™•ì¸ (ì¹˜ëª…ì !)

8) Content Negotiation í…ŒìŠ¤íŠ¸ (H-2)
   - ì¡°ê±´: Accept í—¤ë” ì—†ëŠ” ìš”ì²­
   - ê¸°ëŒ€: ê¸°ì¡´ JSON ì‘ë‹µ (í˜¸í™˜ì„± ìœ ì§€)
   - ê²€ì¦: Content-Typeì´ application/json

9) ì—ëŸ¬ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸
   - ì¡°ê±´: ë„¤íŠ¸ì›Œí¬ ëŠê¹€, íƒ€ì„ì•„ì›ƒ, AbortError
   - ê¸°ëŒ€: graceful degradation, AbortErrorëŠ” ì—ëŸ¬ í‘œì‹œ ì•ˆ í•¨
   - ê²€ì¦: ì—ëŸ¬ ìƒíƒœ ì •ìƒ í‘œì‹œ

==============================================

ì°¸ê³ ì‚¬í•­) ì„±ëŠ¥ ëª©í‘œ

1) ì²« í† í° ì‹œê°„ (Time to First Token, TTFT)
   - ëª©í‘œ: < 1ì´ˆ
   - í˜„ì¬ ì˜ˆìƒ: 0.3~0.5ì´ˆ (gemini-2.0-flash + enum ê°•ì œ)

2) ì „ì²´ ì‘ë‹µ ì‹œê°„
   - ëª©í‘œ: < 1ì´ˆ (S/D 2ë¶„ë¥˜)
   - ìƒì„¸ ë¶„ì„(CAUTION í¬í•¨)ì€ 2ë‹¨ê³„ì—ì„œ ì²˜ë¦¬

3) í† í° ì‚¬ìš©ëŸ‰
   - ì…ë ¥: 60ê°œ ì•„ì´í…œ ì´í•˜ (35ë²ˆ í”„ë¡¬í”„íŠ¸ ì—°ë™)
   - ì¶œë ¥: 1ê°œ (S ë˜ëŠ” D)

==============================================

ì°¸ê³ ì‚¬í•­) ë°°í¬ í™˜ê²½ ì£¼ì˜ì‚¬í•­ (H5)

**Next.js Route Handler ìŠ¤íŠ¸ë¦¬ë° ë²„í¼ë§ ì´ìŠˆ**:
- Route HandlersëŠ” Web Streams APIë¡œ ìŠ¤íŠ¸ë¦¬ë° ì§€ì›
- í•˜ì§€ë§Œ ë°°í¬ í™˜ê²½(í”„ë¡ì‹œ/CDN)ì— ë”°ë¼ ë²„í¼ë§ë  ìˆ˜ ìˆìŒ
- ì²« í† í°ì´ í´ë¼ì´ì–¸íŠ¸ì— ëŠ¦ê²Œ ë„ì°©í•  ìˆ˜ ìˆìŒ

**í•´ê²° ë°©ë²•**:
- í—¤ë”ì— `X-Accel-Buffering: no` ì¶”ê°€ (Nginx)
- `Cache-Control: no-cache, no-store, must-revalidate`
- Vercel: ê¸°ë³¸ì ìœ¼ë¡œ ìŠ¤íŠ¸ë¦¬ë° ì§€ì›
- AWS/Cloudflare: ë²„í¼ë§ ì„¤ì • í™•ì¸ í•„ìš”

==============================================

ì°¸ê³ ì‚¬í•­) ëª¨ë¸ ì„ íƒ ê°€ì´ë“œ

1) ë¹ ë¥¸ íŒë³„ìš© (1ë‹¨ê³„)
   - gemini-2.0-flash (ê¶Œì¥)
   - gpt-4o-mini
   - claude-3-haiku

2) ìƒì„¸ ë¶„ì„ìš© (2ë‹¨ê³„)
   - gemini-2.5-flash (í˜„ì¬ ì‚¬ìš© ì¤‘)
   - gpt-4o
   - claude-3.5-sonnet

3) ëª¨ë¸ë³„ ì˜ˆìƒ TTFT
   | ëª¨ë¸ | ì˜ˆìƒ TTFT |
   |------|----------|
   | gemini-2.0-flash | 0.3~0.5ì´ˆ |
   | gpt-4o-mini | 0.4~0.6ì´ˆ |
   | gemini-2.5-flash | 0.5~0.8ì´ˆ |

==============================================

ì°¸ê³ ì‚¬í•­) ì¹˜ëª…ì  ì´ìŠˆ ì²´í¬ë¦¬ìŠ¤íŠ¸ (êµ¬í˜„ ì‹œ í•„ìˆ˜ í™•ì¸)

**âš ï¸ CRITICAL (êµ¬í˜„ ì „ ë°˜ë“œì‹œ í™•ì¸)**:
| # | ì´ìŠˆ | í•´ê²° ë°©ë²• | í™•ì¸ |
|---|------|----------|------|
| CR-1 | parseStatus fallbackì´ SAFE â†’ ì•Œë ˆë¥´ê¸° ì‚¬ê³  ê°€ëŠ¥ | fallback: DANGER (ëª¨ë¥´ë©´ ìœ„í—˜ìœ¼ë¡œ íŒì •) | â˜ |
| CR-2 | startStreaming stale closure â†’ ì´ì „ ë°ì´í„°ë¡œ ìš”ì²­ | payload íŒŒë¼ë¯¸í„°ë¡œ ëª¨ë“  ë°ì´í„° ì „ë‹¬ | â˜ |

**ğŸ”´ HIGH (êµ¬í˜„ ì‹œ í•„ìˆ˜ í™•ì¸)**:
| # | ì´ìŠˆ | í•´ê²° ë°©ë²• | í™•ì¸ |
|---|------|----------|------|
| H-1 | ì—°ì† ìš”ì²­ ë ˆì´ìŠ¤ â†’ ì´ì „ ì‘ë‹µì´ ìƒíƒœ ë®ì–´ì”€ | AbortController + requestIdRef | â˜ |
| H-2 | ìŠ¤íŠ¸ë¦¬ë° í˜¸í™˜ì„± ê¹¨ì§ â†’ ê¸°ì¡´ í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ | Content Negotiation (Accept í—¤ë” í™•ì¸) | â˜ |
| H-3 | ì‹œê°„ ê¸°ë°˜ í…ŒìŠ¤íŠ¸ CI í”Œë˜í‚¤ â†’ ë¶ˆì•ˆì •í•œ ë¹Œë“œ | Mock ReadableStream + fake timers | â˜ |

**ğŸŸ¡ MEDIUM (êµ¬í˜„ í’ˆì§ˆ)**:
| # | ì´ìŠˆ | í•´ê²° ë°©ë²• | í™•ì¸ |
|---|------|----------|------|
| C1 | responseMimeType ë¶ˆì¼ì¹˜ | text/x.enum + responseSchema.enum ì¡°í•© | â˜ |
| C2 | useRef í›… ê·œì¹™ ìœ„ë°˜ | í›… ìµœìƒìœ„ì—ì„œ ì„ ì–¸ (startStreaming ë‚´ë¶€ âŒ) | â˜ |
| C3 | ttftê°€ ì´ ì†Œìš” ì‹œê°„ìœ¼ë¡œ ì¸¡ì •ë¨ | ì²« ì²­í¬ ì‹œì ì— ttftMs ì €ì¥ | â˜ |
| C4 | ë‹¨ì¼ í† í° ë³´ì¥ ê³¼ì¥ | text/x.enumìœ¼ë¡œ enum ê°•ì œ | â˜ |
| C5 | CAUTION ê·œì¹™ ëª¨í˜¸ | 2ë¶„ë¥˜(S/D)ë¡œ ë‹¨ìˆœí™”, CëŠ” 2ë‹¨ê³„ì—ì„œ | â˜ |
| C6 | stopSequencesì— ê³µë°± â†’ ë¹ˆ ì‘ë‹µ | stopSequences: ["\n"]ë§Œ ì‚¬ìš© | â˜ |
| C7 | accumulated í˜ì´ë¡œë“œ ì¦ê°€ | ê°œë°œ í™˜ê²½ì—ì„œë§Œ í¬í•¨ (process.env ë¶„ê¸°) | â˜ |
| C8 | ë°°í¬ í™˜ê²½ ë²„í¼ë§ | X-Accel-Buffering: no í—¤ë” ì¶”ê°€ | â˜ |
| C9 | firstTokenTime ë ˆì´ìŠ¤ | useRef + ë¡œì»¬ ë³€ìˆ˜ | â˜ |
