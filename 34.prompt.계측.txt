주제: 메뉴→알레르기 위험도 흐름의 병목 계측 (React Native, 코드 최소 변경)

목표: 총 30–40초 지연을 구간별로 분리해 기록하고, 네트워크/파싱/매핑/렌더 중 어디가 병목인지 수치로 확인한다.

구간 정의(동일 요청 ID로 추적):
- 네트워크: 요청 시작 → 응답 수신 완료
- 파싱: 응답 수신 → JSON 파싱 완료
- 필터링/비즈: 파싱 완료 → 알레르기 매핑 완료
- 렌더링: 매핑 완료 → UI 표시 완료

클라이언트 계측(React Native):
- 각 구간 시작/종료에 `performance.now()` 찍는 래퍼 사용, 요청별 ID 포함.
- 로그를 콘솔/Flipper로 확인; 네트워크 응답 크기와 소요 시간 함께 기록.
- Flipper Performance / RN DevTools로 JS 프레임 드롭·렌더 트리 재조정 확인, 화면 전환 시 CPU/GPU 차트 확인.
- React DevTools Profiler로 리스트/카테고리 컴포넌트 렌더 비용 측정.

네트워크 병목 분리:
- 동일 요청을 Wi-Fi / 오프라인 캐시 / 느린 네트워크(Dev Menu Network conditioning 또는 Charles/Proxyman throttle)에서 반복 측정.
- 응답 헤더의 Content-Length, Transfer-Encoding, 압축 여부 확인; 응답 페이로드 크기 로그.

파싱/필터링 병목 분리:
- 응답 바이트 수 vs 파싱 시간 상관 기록(큰 JSON이면 구조 최적화 필요 신호).
- 알레르기 매핑 함수를 단독 실행해 입력 크기별 실행 시간 프로파일.

렌더링 병목 분리:
- 리스트 렌더 가상화 여부(FlatList/SectionList) 확인, Profiler에서 해당 구간 프레임 드롭 여부 체크.
- Skeleton/로딩 → 실제 UI 전환 시간 측정해 데이터 준비 이후 지연인지 판단.

수집 방식:
- 동일 시나리오 3회 이상 반복, 평균/분산 기록.
- 표로 정리: 요청 ID, 네트워크(ms), 파싱(ms), 매핑(ms), 렌더(ms), 총합, 응답 크기.

결과 활용:
- 표에서 가장 큰 구간을 병목으로 정의하고, 그에 맞춰 최적화 우선순위 설정
  (네트워크 크면 응답 축소/압축, 파싱·매핑 크면 데이터 구조 최적화, 렌더 크면 리스트 최적화).

