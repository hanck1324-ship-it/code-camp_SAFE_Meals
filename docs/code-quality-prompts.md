# SafeMeals 코드 품질 강화 프롬프트 모음

## 사용 방법
아래 프롬프트들을 Claude Code에 입력하여 코드 품질 검토 및 개선을 수행할 수 있습니다.

---

## Tech Stack (기술 스택)

### AI / ML
| 기술 | 용도 | 비고 |
|------|------|------|
| **Google Gemini API** (`@google/generative-ai`) | 메뉴 이미지 분석, 알러지 위험도 판정 | gemini-2.5-flash-lite (빠른 판정), gemini-3-flash-preview (정밀 분석) |
| **Google Cloud Vision API** | OCR (메뉴판 텍스트 추출) | `google-vision-ocr.ts` |
| **Tesseract.js** | 클라이언트 사이드 OCR 폴백 | 오프라인/비용 절감용 |

### Frontend (Web)
| 기술 | 버전 | 용도 |
|------|------|------|
| **Next.js** | 14.2.5 | React 프레임워크, App Router |
| **React** | 18.3.1 | UI 라이브러리 |
| **TypeScript** | 5.3.3 | 타입 안전성 |
| **Tailwind CSS** | 3.4.1 | 스타일링 |
| **Radix UI** | - | 헤드리스 UI 컴포넌트 |
| **Zustand** | 4.5.2 | 전역 상태 관리 |
| **TanStack Query** | 5.90.12 | 서버 상태 관리 |
| **React Hook Form + Zod** | - | 폼 관리 및 유효성 검증 |
| **Leaflet** | 1.9.4 | 지도 (안전한 식당 표시) |

### Frontend (Mobile)
| 기술 | 버전 | 용도 |
|------|------|------|
| **Expo** | 52.0.0 | React Native 프레임워크 |
| **React Native** | 0.76.9 | 크로스플랫폼 모바일 |
| **Expo Camera** | 16.0.0 | 메뉴 스캔 카메라 |
| **Expo Router** | 4.0.0 | 파일 기반 라우팅 |
| **React Native WebView** | 13.12.5 | 웹뷰 연동 |

### Backend / BaaS
| 기술 | 용도 |
|------|------|
| **Supabase** | 인증, PostgreSQL DB, Storage |
| **Next.js API Routes** | 서버리스 API 엔드포인트 |
| **PortOne** | 결제 연동 |

### 테스트 / 품질
| 기술 | 용도 |
|------|------|
| **Jest** | 단위 테스트 |
| **Playwright** | E2E 테스트 |
| **Testing Library** | 컴포넌트 테스트 |
| **ESLint + Prettier** | 코드 린팅/포매팅 |
| **Husky + lint-staged** | Git 훅 자동화 |

### 인프라 / 도구
| 기술 | 용도 |
|------|------|
| **pnpm** | 패키지 매니저 (모노레포) |
| **Turborepo** 구조 | apps/web, apps/mobile, packages/shared |

---

## 1. 오버엔지니어링 검토 프롬프트

### 1.1 전체 프로젝트 오버엔지니어링 검토
```
이 프로젝트에서 오버엔지니어링된 부분을 찾아줘.

검토 기준:
1. 사용되지 않는 추상화 레이어 (불필요한 wrapper, adapter 패턴)
2. 너무 많은 설정 옵션이 있는 컴포넌트
3. 한 번만 사용되는 유틸리티 함수
4. 지나치게 세분화된 파일/폴더 구조
5. 불필요한 타입 정의 (중복, 미사용)
6. 과도한 에러 핸들링 (발생하지 않을 에러 케이스)
7. 미래를 위한 확장성 코드 (YAGNI 위반)

각 발견 사항에 대해:
- 파일 경로와 라인 번호
- 왜 오버엔지니어링인지 설명
- 단순화 방안 제안
```

### 1.2 특정 파일 오버엔지니어링 검토
```
[파일 경로]를 분석해서 오버엔지니어링된 부분을 찾아줘.

검토 기준:
1. 이 파일의 핵심 목적은 무엇인가?
2. 그 목적을 달성하는 데 불필요한 코드가 있는가?
3. 더 간단한 방법으로 같은 결과를 얻을 수 있는가?
4. 미사용 import, 변수, 함수가 있는가?
5. 복잡한 조건문을 단순화할 수 있는가?

결과를 표로 정리해줘:
| 위치 | 문제 | 간소화 방안 | 우선순위 |
```

### 1.3 컴포넌트 복잡도 분석
```
apps/web/src/features 폴더의 모든 컴포넌트를 분석해서 복잡도가 높은 것들을 찾아줘.

측정 기준:
1. 파일 라인 수 (300줄 이상은 분리 필요)
2. props 개수 (10개 이상은 재설계 필요)
3. useState 호출 수 (5개 이상은 상태 관리 개선 필요)
4. useEffect 호출 수 (3개 이상은 리팩토링 필요)
5. 중첩 삼항 연산자 사용
6. 조건부 렌더링 깊이 (3단계 이상)

결과:
| 컴포넌트 | 라인수 | Props | useState | useEffect | 권장사항 |
```

---

## 2. 코드 품질 강화 프롬프트

### 2.1 TypeScript 타입 안전성 검토
```
이 프로젝트의 TypeScript 타입 안전성을 검토해줘.

검토 항목:
1. `any` 타입 사용 현황 및 대체 방안
2. `as` 타입 단언 남용 여부
3. optional chaining(?.) 과다 사용
4. null/undefined 처리 일관성
5. API 응답 타입 정의 상태
6. Zod 스키마와 TypeScript 타입 동기화

각 항목에 대해:
- 현재 상태 (문제 수)
- 심각도 (높음/중간/낮음)
- 개선 예시 코드
```

### 2.2 React 베스트 프랙티스 검토
```
이 프로젝트의 React 코드가 베스트 프랙티스를 따르는지 검토해줘.

검토 항목:
1. 불필요한 리렌더링 (useMemo, useCallback 누락)
2. 컴포넌트 분리 원칙 (단일 책임)
3. 상태 끌어올리기 vs 상태 내리기
4. key prop 올바른 사용
5. 이벤트 핸들러 인라인 함수 남용
6. Context 과다 사용
7. Custom hook 추출 가능한 로직

문제가 있는 코드와 개선된 코드를 비교해서 보여줘.
```

### 2.3 성능 최적화 검토
```
이 프로젝트의 성능 최적화 상태를 검토해줘.

검토 항목:
1. 번들 사이즈 최적화
   - 동적 import 사용 여부
   - tree-shaking 가능한 import 사용
   - 큰 라이브러리 대체 가능 여부

2. 렌더링 최적화
   - React.memo 필요한 곳
   - 불필요한 상태 업데이트
   - 가상화 필요한 리스트

3. 네트워크 최적화
   - API 호출 중복
   - 캐싱 전략
   - 이미지 최적화

4. 메모리 최적화
   - 메모리 누수 가능성
   - 이벤트 리스너 정리

각 항목별 현재 점수(1-5)와 개선 방안을 제시해줘.
```

---

## 3. 테스트 품질 검토 프롬프트

### 3.1 테스트 커버리지 갭 분석
```
이 프로젝트의 테스트 커버리지 갭을 분석해줘.

분석 대상:
1. 핵심 비즈니스 로직 중 테스트되지 않은 부분
2. 에러 핸들링 테스트 누락
3. 엣지 케이스 테스트 누락
4. 통합 테스트 필요한 영역

결과 형식:
| 파일/함수 | 테스트 상태 | 누락된 테스트 케이스 | 우선순위 |
```

### 3.2 테스트 품질 검토
```
apps/web/tests 폴더의 테스트 코드 품질을 검토해줘.

검토 기준:
1. 테스트 이름이 테스트 내용을 명확히 설명하는가?
2. AAA 패턴(Arrange-Act-Assert)을 따르는가?
3. 하나의 테스트가 하나의 동작만 검증하는가?
4. 테스트 간 의존성이 없는가?
5. Mock 사용이 적절한가?
6. 불안정한(flaky) 테스트가 있는가?

개선이 필요한 테스트와 개선 방안을 제시해줘.
```

### 3.3 새로운 테스트 케이스 생성
```
[파일 경로]에 대한 테스트 케이스를 생성해줘.

요구사항:
1. 모든 public 함수에 대한 테스트
2. 정상 케이스 + 엣지 케이스 + 에러 케이스
3. Playwright 또는 Jest 형식
4. AAA 패턴 사용
5. 한글로 테스트 이름 작성

생성 형식:
- 파일명: [원본파일명].spec.ts
- 각 테스트에 주석으로 테스트 의도 설명
```

---

## 4. 보안 검토 프롬프트

### 4.1 보안 취약점 스캔
```
이 프로젝트의 보안 취약점을 스캔해줘.

검토 항목:
1. XSS 취약점 (dangerouslySetInnerHTML, innerHTML)
2. SQL Injection 가능성
3. 민감한 정보 노출 (API 키, 토큰)
4. 안전하지 않은 의존성
5. CSRF 보호
6. 인증/인가 우회 가능성
7. 입력 검증 누락

각 발견 사항에 대해:
- 심각도 (Critical/High/Medium/Low)
- 영향 범위
- 수정 방안
- 코드 예시
```

### 4.2 환경 변수 보안 검토
```
이 프로젝트의 환경 변수 관리 상태를 검토해줘.

검토 항목:
1. 하드코딩된 민감 정보
2. NEXT_PUBLIC_ prefix 적절성
3. .env 파일 gitignore 여부
4. 프로덕션 vs 개발 환경 분리
5. 환경 변수 문서화 상태

결과:
| 변수명 | 노출 위험 | 현재 상태 | 권장 조치 |
```

---

## 5. 코드 일관성 검토 프롬프트

### 5.1 네이밍 컨벤션 검토
```
이 프로젝트의 네이밍 컨벤션 일관성을 검토해줘.

검토 항목:
1. 파일명 (kebab-case vs camelCase)
2. 컴포넌트명 (PascalCase)
3. 함수명 (camelCase, 동사로 시작)
4. 변수명 (camelCase)
5. 상수명 (UPPER_SNAKE_CASE)
6. 타입/인터페이스명 (PascalCase)
7. CSS 클래스명 (Tailwind 일관성)

불일치 항목과 권장 수정 사항을 정리해줘.
```

### 5.2 폴더 구조 검토
```
이 프로젝트의 폴더 구조를 검토해줘.

검토 항목:
1. Feature-based vs Layer-based 일관성
2. 순환 의존성 여부
3. 재사용 컴포넌트 위치 적절성
4. 공통 유틸리티 위치
5. 타입 정의 위치
6. 테스트 파일 위치

현재 구조의 문제점과 개선된 구조를 제안해줘.
```

---

## 6. 리팩토링 프롬프트

### 6.1 대규모 파일 분리
```
[파일 경로]가 너무 커서 분리가 필요해.

현재 파일 분석:
1. 현재 라인 수
2. 포함된 컴포넌트/함수 목록
3. 의존성 그래프

분리 계획:
1. 어떻게 나눌지 (기능별 / 레이어별)
2. 새로운 파일 구조
3. import/export 관계
4. 마이그레이션 순서

분리 후 각 파일의 코드를 작성해줘.
```

### 6.2 중복 코드 제거
```
이 프로젝트에서 중복된 코드를 찾아서 정리해줘.

검토 대상:
1. 동일/유사한 함수
2. 반복되는 컴포넌트 패턴
3. 중복 타입 정의
4. 중복 스타일 (Tailwind 클래스 조합)
5. 중복 API 호출 패턴

각 중복에 대해:
- 위치 (파일 경로들)
- 추출할 공통 코드
- 리팩토링 방안
```

### 6.3 레거시 코드 현대화
```
이 프로젝트에서 레거시 패턴을 사용하는 코드를 찾아서 현대화해줘.

검토 대상:
1. 클래스 컴포넌트 → 함수형 컴포넌트
2. componentDidMount → useEffect
3. this.setState → useState
4. var → const/let
5. 콜백 지옥 → async/await
6. lodash → 네이티브 메서드
7. moment → dayjs 또는 date-fns

각 발견에 대해 변환 전/후 코드를 보여줘.
```

---

## 7. 정기 점검 프롬프트

### 7.1 주간 코드 품질 리포트
```
지난 1주일간 변경된 코드의 품질을 리포트해줘.

리포트 내용:
1. 새로 추가된 파일 수 / 삭제된 파일 수
2. 라인 수 변화
3. 새로 도입된 any 타입 수
4. 새로운 console.log 수
5. 테스트 커버리지 변화
6. ESLint 경고/에러 변화
7. 기술 부채 증가/감소

개선 권장 사항 3가지를 우선순위와 함께 제시해줘.
```

### 7.2 의존성 상태 점검
```
이 프로젝트의 의존성 상태를 점검해줘.

점검 항목:
1. 보안 취약점이 있는 패키지
2. 크게 버전이 뒤처진 패키지 (major 버전 차이)
3. deprecated된 패키지
4. 사용하지 않는 패키지
5. 중복 설치된 패키지
6. peer dependency 경고

결과:
| 패키지 | 현재 버전 | 최신 버전 | 상태 | 조치 필요 |
```

---

## 사용 팁

1. **정기 실행**: 주 1회 "주간 코드 품질 리포트" 실행
2. **PR 전 실행**: 변경된 파일에 대해 "특정 파일 오버엔지니어링 검토" 실행
3. **대규모 변경 전**: "전체 프로젝트 오버엔지니어링 검토" 실행
4. **배포 전**: "보안 취약점 스캔" 실행

---

## 자동화 스크립트 (선택)

```bash
# package.json에 추가
"scripts": {
  "quality:check": "pnpm lint && pnpm test:coverage",
  "quality:deps": "npm audit && npx depcheck",
  "quality:size": "npx size-limit"
}
```
